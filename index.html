<!DOCTYPE html>

<html>
<head>
  <title>then.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>then.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>v0.12.3 <a href="https://travis-ci.org/zensh/then.js"><img src="https://travis-ci.org/zensh/then.js.png?branch=master" alt="Build Status"></a></p>
<p>小巧、简单、强大的链式异步编程工具！</p>
<p><strong>Github:</strong> <a href="https://github.com/teambition/then.js">https://github.com/teambition/then.js</a></p>
<p><strong>License:</strong> MIT</p>

            </div>

            <div class="content"><div class='highlight'><pre>
<span class="hljs-comment">/* global module, define, setImmediate, console  */</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
<span class="hljs-pi">
  'use strict'</span>;

  <span class="hljs-keyword">var</span> slice = [].slice,</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>nextTick 用于异步执行函数，避免 <code>Maximum call stack size exceeded</code>
MutationObserver 和 MessageChannel 目前不适合用来模拟 setImmediate, 无法正常 GC</p>

            </div>

            <div class="content"><div class='highlight'><pre>    nextTick = <span class="hljs-keyword">typeof</span> setImmediate === <span class="hljs-string">'function'</span> ? setImmediate : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> {</span>
      setTimeout(fn, <span class="hljs-number">0</span>);
    },
    isArray = <span class="hljs-built_in">Array</span>.isArray || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> {</span>
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">'[object Array]'</span>;
    };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span><span class="hljs-params">(obj)</span> {</span>
    <span class="hljs-keyword">return</span> obj == <span class="hljs-literal">null</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span><span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">'function'</span>;
  }</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>参数不合法时生成相应的错误</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorify</span><span class="hljs-params">(obj, method, type)</span> {</span>
    type = type || <span class="hljs-string">'array'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Argument '</span> + (obj &amp;&amp; obj.toString()) + <span class="hljs-string">' in "'</span> + method + <span class="hljs-string">'" is not a '</span> + type + <span class="hljs-string">'!'</span>);
  }</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>用于生成 <code>each</code> 和 <code>parallel</code> 的 <code>next</code></p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parallelNext</span><span class="hljs-params">(cont, result, counter, i)</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span><span class="hljs-params">(error, value)</span> {</span>
      <span class="hljs-keyword">if</span> (!isNull(error)) <span class="hljs-keyword">return</span> cont(error);
      result[i] = value;
      <span class="hljs-keyword">return</span> --counter.i &lt; <span class="hljs-number">0</span> &amp;&amp; cont(<span class="hljs-literal">null</span>, result);
    }
    next._isCont = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> next;
  }</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h2 id="-each-">内部 <strong>each</strong> 函数</h2>
<p>将一组数据 <code>array</code> 分发给任务迭代函数 <code>iterator</code>，并行执行，<code>cont</code> 处理最后结果</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span><span class="hljs-params">(cont, array, iterator)</span> {</span>
    <span class="hljs-keyword">var</span> end, result = [], counter = {};

    <span class="hljs-keyword">if</span> (!isArray(array)) <span class="hljs-keyword">return</span> cont(errorify(array, <span class="hljs-string">'each'</span>));
    counter.i = end = array.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cont(<span class="hljs-literal">null</span>, result);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= end; i++) {
      iterator(parallelNext(cont, result, counter, i), array[i], i, array);
    }
  }</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2 id="-parallel-">内部 <strong>parallel</strong> 函数</h2>
<p>并行执行一组 <code>array</code> 任务，<code>cont</code> 处理最后结果</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parallel</span><span class="hljs-params">(cont, array)</span> {</span>
    <span class="hljs-keyword">var</span> end, result = [], counter = {};

    <span class="hljs-keyword">if</span> (!isArray(array)) <span class="hljs-keyword">return</span> cont(errorify(array, <span class="hljs-string">'parallel'</span>));
    counter.i = end = array.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cont(<span class="hljs-literal">null</span>, result);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= end; i++) {
      array[i](parallelNext(cont, result, counter, i), i, array);
    }
  }</pre></div></div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2 id="-eachseries-">内部 <strong>eachSeries</strong> 函数</h2>
<p>将一组数据 <code>array</code> 分发给任务迭代函数 <code>iterator</code>，串行执行，<code>cont</code> 处理最后结果</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eachSeries</span><span class="hljs-params">(cont, array, iterator)</span> {</span>
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, end, result = [];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span><span class="hljs-params">(err, value)</span> {</span>
      <span class="hljs-keyword">if</span> (!isNull(err)) <span class="hljs-keyword">return</span> cont(err);
      result[i] = value;
      <span class="hljs-keyword">if</span> (++i &gt; end) <span class="hljs-keyword">return</span> cont(<span class="hljs-literal">null</span>, result);
      nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">try</span> {
          iterator(next, array[i], i, array);
        } <span class="hljs-keyword">catch</span> (error) {
          cont(error);
        }
      });
    }
    next._isCont = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">if</span> (!isArray(array)) <span class="hljs-keyword">return</span> cont(errorify(array, <span class="hljs-string">'eachSeries'</span>));
    end = array.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cont(<span class="hljs-literal">null</span>, result);
    iterator(next, array[i], i, array);
  }</pre></div></div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="-series-">内部 <strong>series</strong> 函数</h2>
<p>串行执行一组 <code>array</code> 任务，<code>cont</code> 处理最后结果</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">series</span><span class="hljs-params">(cont, array)</span> {</span>
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, end, result = [];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span><span class="hljs-params">(err, value)</span> {</span>
      <span class="hljs-keyword">if</span> (!isNull(err)) <span class="hljs-keyword">return</span> cont(err);
      result[i] = value;
      <span class="hljs-keyword">if</span> (++i &gt; end) <span class="hljs-keyword">return</span> cont(<span class="hljs-literal">null</span>, result);
      nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">try</span> {
          array[i](next, i, array);
        } <span class="hljs-keyword">catch</span> (error) {
          cont(error);
        }
      });
    }
    next._isCont = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">if</span> (!isArray(array)) <span class="hljs-keyword">return</span> cont(errorify(array, <span class="hljs-string">'series'</span>));
    end = array.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cont(<span class="hljs-literal">null</span>, result);
    array[i](next, i, array);
  }</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>封装 handler，<code>_isCont</code> 属性判定 handler 是不是 <code>cont</code> ，不是则将 <code>cont</code> 注入成第一个参数</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapTaskHandler</span><span class="hljs-params">(cont, handler)</span> {</span>
    <span class="hljs-keyword">return</span> handler._isCont ? handler : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      handler.apply(<span class="hljs-literal">null</span>, [cont].concat(slice.call(<span class="hljs-built_in">arguments</span>)));
    };
  }</pre></div></div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h2 id="-thenjs-">内部 <strong>Thenjs</strong> 构造函数</h2>
<p>所有 <strong>Then</strong> 链从此继承</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Thenjs</span><span class="hljs-params">()</span> {</span>}</pre></div></div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>定义默认 <code>debug</code> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>  Thenjs.prototype.debug = <span class="hljs-keyword">typeof</span> console === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    console.log.apply(console, <span class="hljs-built_in">arguments</span>);
  };</pre></div></div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h2 id="-then-">内部 <strong>Then</strong> 构造函数</h2>
<p>每一条 <strong>Then</strong> 链的所有 <strong>Then</strong> 对象继承于共同的 <strong>Then</strong> 构造函数
不同的 <strong>Then</strong> 链的 <strong>Then</strong> 构造函数不同，但都继承于 <strong>Thenjs</strong> 构造函数</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closureThen</span><span class="hljs-params">(debug)</span> {</span></pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>新的 <strong>Then</strong> 构造函数</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Then</span><span class="hljs-params">()</span> {</span>}</pre></div></div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>继承于 <strong>Thenjs</strong> 构造函数</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> prototype = Then.prototype = <span class="hljs-keyword">new</span> Thenjs(),</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>保存该链上的所有 <code>fail</code> 方法，用于夸链处理 error</p>

            </div>

            <div class="content"><div class='highlight'><pre>      fail = [],</pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>链计数器，用于 debug 模式</p>

            </div>

            <div class="content"><div class='highlight'><pre>      chain = <span class="hljs-number">0</span>;</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>内部核心 <strong>continuation</strong> 方法
<strong>continuation</strong> 收集任务结果，触发下一个链，它被注入各个 handler
其参数采用 <strong>node.js</strong> 的 <strong>callback</strong> 形式：(error, arg1, arg2, …)</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">continuation</span><span class="hljs-params">(err)</span> {</span>
      <span class="hljs-keyword">var</span> errorHandler, successHandler, self = <span class="hljs-keyword">this</span>, args = <span class="hljs-built_in">arguments</span>;</pre></div></div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>then链上的结果已经处理，若重复执行 cont 则直接跳过；</p>

            </div>

            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (self._result === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">if</span> (self._result) {</pre></div></div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>_result 已存在，表明上一次 cont 没有 handler 处理
这是第二次进入 cont 继续处理，并标记结果已处理，这是由续接 <strong>Then</strong> 链触发</p>

            </div>

            <div class="content"><div class='highlight'><pre>        self._result = <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.debug) {</pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>表明这是第一次进入 cont，若存在 debug 则执行，对于同一结果保证 debug 只执行一次；</p>

            </div>

            <div class="content"><div class='highlight'><pre>        chain += <span class="hljs-number">1</span>;
        self.debug.apply(self, [<span class="hljs-string">'\nResult of chain '</span> + chain + <span class="hljs-string">': '</span>].concat(slice.call(args)));
      }

      errorHandler = self._fail ? fail.shift() : self._error;
      successHandler = self._success || self._each || self._eachSeries || self._parallel || self._series;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (self._all) <span class="hljs-keyword">return</span> self._all.apply(<span class="hljs-literal">null</span>, args);
        <span class="hljs-keyword">if</span> (!isNull(err)) <span class="hljs-keyword">throw</span> err;
        <span class="hljs-keyword">if</span> (successHandler) {
          successHandler.apply(<span class="hljs-literal">null</span>, slice.call(args, <span class="hljs-number">1</span>));
        } <span class="hljs-keyword">else</span> {</pre></div></div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>对于正确结果，<strong>Then</strong> 链上没有相应 handler 处理，则在 <strong>Then</strong> 链上保存结果，等待下一次处理。</p>

            </div>

            <div class="content"><div class='highlight'><pre>          self._result = args;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dealError</span><span class="hljs-params">(error)</span> {</span>
        error.stack = error.stack || error.description;
        <span class="hljs-keyword">if</span> (isNull(err) &amp;&amp; self._nextThen) {</pre></div></div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>本次 cont catch的 error，直接放到下一链处理</p>

            </div>

            <div class="content"><div class='highlight'><pre>          continuation.call(self._nextThen, error);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errorHandler || fail.length) {</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>获取本链的 error handler 或者链上的fail handler</p>

            </div>

            <div class="content"><div class='highlight'><pre>          errorHandler = errorHandler || fail.shift();
          errorHandler.call(<span class="hljs-literal">null</span>, error);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thenjs.onerror) {</pre></div></div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>如果定义了全局 <strong>onerror</strong>，则用它处理</p>

            </div>

            <div class="content"><div class='highlight'><pre>          thenjs.onerror(error);
        } <span class="hljs-keyword">else</span> {</pre></div></div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>对于 error，<strong>Then</strong> 链上没有相应 handler 处理，则在 <strong>Then</strong> 链上保存结果，等待下一次处理。</p>

            </div>

            <div class="content"><div class='highlight'><pre>          self._result = [error];
        }
      }

      <span class="hljs-keyword">try</span> {
        execute();
      } <span class="hljs-keyword">catch</span> (error) {
        dealError(error);
      }
    }</pre></div></div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>注入 cont，执行 fn，并返回新的 <strong>Then</strong> 对象</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thenFactory</span><span class="hljs-params">(fn, context)</span> {</span>
      <span class="hljs-keyword">var</span> then = <span class="hljs-keyword">new</span> Then();

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cont</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> continuation.apply(then, <span class="hljs-built_in">arguments</span>);
      }</pre></div></div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>标记 cont，cont 作为 handler 时不会被注入 cont，见 <code>wrapTaskHandler</code></p>

            </div>

            <div class="content"><div class='highlight'><pre>      cont._isCont = <span class="hljs-literal">true</span>;</pre></div></div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>注入 cont</p>

            </div>

            <div class="content"><div class='highlight'><pre>      fn(cont, context);
      <span class="hljs-keyword">if</span> (context) {
        context._nextThen = then;</pre></div></div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>检查上一链的结果是否处理，未处理则处理，用于续接 <strong>Then</strong> 链</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (context._result) {
          nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            continuation.apply(context, context._result);
          });
        }
      }
      <span class="hljs-keyword">return</span> then;
    }

    prototype.constructor = Then;</pre></div></div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>是否开启 <strong>debug</strong> 模式，若开启，则将每一步的结果输入 <code>debug</code> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!debug || isFunction(debug)) prototype.debug = debug;

    <span class="hljs-keyword">if</span> (!isFunction(thenjs.onerror)) thenjs.onerror = <span class="hljs-literal">null</span>;</pre></div></div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><strong>Then</strong> 对象上的 <strong>all</strong> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>    prototype.all = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(allHandler)</span> {</span>
      <span class="hljs-keyword">return</span> thenFactory(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont, self)</span> {</span>
        self._all = wrapTaskHandler(cont, allHandler);
      }, <span class="hljs-keyword">this</span>);
    };</pre></div></div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><strong>Then</strong> 对象上的 <strong>then</strong> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>    prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(successHandler, errorHandler)</span> {</span>
      <span class="hljs-keyword">return</span> thenFactory(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont, self)</span> {</span>
        self._success = wrapTaskHandler(cont, successHandler);
        self._error = errorHandler &amp;&amp; wrapTaskHandler(cont, errorHandler);
      }, <span class="hljs-keyword">this</span>);
    };</pre></div></div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p><strong>Then</strong> 对象上的 <strong>fail</strong> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>    prototype.fail = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(errorHandler)</span> {</span>
      <span class="hljs-keyword">return</span> thenFactory(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont, self)</span> {</span>
        self._fail = wrapTaskHandler(cont, errorHandler);</pre></div></div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>对于链上的 fail 方法，如果无 error ，则穿透该链，将结果输入下一链</p>

            </div>

            <div class="content"><div class='highlight'><pre>        self._success = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
          cont.apply(<span class="hljs-literal">null</span>, [<span class="hljs-literal">null</span>].concat(slice.call(<span class="hljs-built_in">arguments</span>)));
        };</pre></div></div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>将 fail 存入闭包，使得在此链之前产生的 error 也能被 fail 捕捉</p>

            </div>

            <div class="content"><div class='highlight'><pre>        fail.push(self._fail);
      }, <span class="hljs-keyword">this</span>);
    };</pre></div></div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><strong>Then</strong> 对象上的 <strong>each</strong> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>    prototype.each = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array, iterator)</span> {</span>
      <span class="hljs-keyword">return</span> thenFactory(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont, self)</span> {</span>
        self._each = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dArray, dIterator)</span> {</span></pre></div></div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>优先使用定义的参数，如果没有定义参数，则从上一链结果从获取
<code>dArray</code>, <code>dIterator</code> 来自于上一链的 <strong>cont</strong>
下同</p>

            </div>

            <div class="content"><div class='highlight'><pre>          each(cont, array || dArray, iterator || dIterator);
        };
      }, <span class="hljs-keyword">this</span>);
    };</pre></div></div>

        </li>


        <li id="section-38">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p><strong>Then</strong> 对象上的 <strong>eachSeries</strong> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>    prototype.eachSeries = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array, iterator)</span> {</span>
      <span class="hljs-keyword">return</span> thenFactory(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont, self)</span> {</span>
        self._eachSeries = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dArray, dIterator)</span> {</span>
          eachSeries(cont, array || dArray, iterator || dIterator);
        };
      }, <span class="hljs-keyword">this</span>);
    };</pre></div></div>

        </li>


        <li id="section-39">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p><strong>Then</strong> 对象上的 <strong>parallel</strong> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>    prototype.parallel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array)</span> {</span>
      <span class="hljs-keyword">return</span> thenFactory(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont, self)</span> {</span>
        self._parallel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dArray)</span> {</span>
          parallel(cont, array || dArray);
        };
      }, <span class="hljs-keyword">this</span>);
    };</pre></div></div>

        </li>


        <li id="section-40">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p><strong>Then</strong> 对象上的 <strong>series</strong> 方法</p>

            </div>

            <div class="content"><div class='highlight'><pre>    prototype.series = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array)</span> {</span>
      <span class="hljs-keyword">return</span> thenFactory(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont, self)</span> {</span>
        self._series = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dArray)</span> {</span>
          series(cont, array || dArray);
        };
      }, <span class="hljs-keyword">this</span>);
    };

    <span class="hljs-keyword">return</span> thenFactory;
  }</pre></div></div>

        </li>


        <li id="section-41">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>异步执行函数，同时捕捉错误，用 <code>cont</code> 处理。</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deferTask</span><span class="hljs-params">(task, cont, arg1, arg2)</span> {</span>
    nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">try</span> {
        task(cont, arg1, arg2);
      } <span class="hljs-keyword">catch</span> (error) {
        cont(error);
      }
    });
  }</pre></div></div>

        </li>


        <li id="section-42">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>工厂函数，生成 thenjs.each 和 thenjs.eachSeries</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eachAndSeriesFactory</span><span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array, iterator, debug)</span> {</span>
      <span class="hljs-keyword">return</span> closureThen(debug)(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont)</span> {</span>
        deferTask(fn, cont, array, iterator);
      });
    };
  }</pre></div></div>

        </li>


        <li id="section-43">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>工厂函数，生成 thenjs.parallel 和 thenjs.series</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parallelAndSeriesFactory</span><span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array, debug)</span> {</span>
      <span class="hljs-keyword">return</span> closureThen(debug)(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont)</span> {</span>
        deferTask(fn, cont, array);
      });
    };
  }</pre></div></div>

        </li>


        <li id="section-44">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>对外输出的主函数</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thenjs</span><span class="hljs-params">(startFn, debug)</span> {</span>
    <span class="hljs-keyword">return</span> closureThen(debug)(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cont)</span> {</span>
      deferTask(startFn, cont);
    });
  }

  thenjs.nextTick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> {</span>
    nextTick(fn);
  };
  thenjs.each = eachAndSeriesFactory(each);
  thenjs.eachSeries = eachAndSeriesFactory(eachSeries);
  thenjs.parallel = parallelAndSeriesFactory(parallel);
  thenjs.series = parallelAndSeriesFactory(series);

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> module === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> module.exports === <span class="hljs-string">'object'</span>) {
    module.exports = thenjs;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {
    define([], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span><span class="hljs-keyword">return</span> thenjs;});
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> window === <span class="hljs-string">'object'</span>) {
    window.thenjs = thenjs;
  }
}());</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
